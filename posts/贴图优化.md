---
title: 2dgs结果贴图优化
date: 2025-11-26
excerpt: 用 PyTorch3D 将已有网格（OBJ）进行“贴图优化”（主要学习/优化纹理贴图），通过渲染和比较相机视图的 RGB 图像，最小化渲染图与真实图像的 L2 RGB 损失，从而调整纹理贴图（Texture maps）。
tags: ['PyTorch3D','贴图','优化', '算法', '研发']
readTime: 20min
---

**概览**  
- 文件：try_fit_textures.py  
- 目的：用 PyTorch3D 将已有网格（OBJ）进行“贴图优化”（主要学习/优化纹理贴图），通过渲染和比较相机视图的 RGB 图像，最小化渲染图与真实图像的 L2 RGB 损失，从而调整纹理贴图（Texture maps）。  
- 输入：一个 OBJ 网格文件（`obj_filename`）、一个 COLMAP 风格的数据集（路径 `path`、子目录 `camera_sub`、图像目录 `images`），以及可选的 mask。  
- 输出：训练过程中向 TensorBoard 写入图像/损失，最后将优化后的网格和纹理导出为 OBJ（包含 `texture_map`）。

**主要流程 / 关键部分**
- 环境/依赖与设备：
  - 导入大量库（PyTorch, PyTorch3D, OpenCV, imageio, tqdm, TensorBoard 等）。
  - 将 `device` 设为 CUDA（如可用）或 CPU。
  - 将一个 tutorial 路径加入 `sys.path`（line: sys.path.append(...)）。

- 数据读取模块：
  - `readColmapDatasets(path, images, camera_sub, downscale, device)`：尝试读取 COLMAP 二进制（`images.bin`/`cameras.bin`）或文本（`images.txt`/`cameras.txt`），返回 camera 对象列表、RGB 图像列表与 alpha mask 列表。
  - `readColmapCameras(cam_extrinsics, cam_intrinsics, downscale)`：将 COLMAP 相机外参/内参转换成 PyTorch3D 的 `PerspectiveCameras`（为每个视图生成一个 camera 对象列表）。
  - `readColmapImages(images_folder, cam_extrinsics, downscale, device)`：读取图像、按 `downscale` 缩放、读取对应 mask（若存在），将图像与 mask 转成 torch tensors（注意：有 DEBUG_IDX 限制，只读取前几个图像）。

- 渲染器设置：
  - 构造软光栅化设置 `RasterizationSettings`（`blur_radius` 使用 sigma -> log 公式，`faces_per_pixel=50`, `bin_size=0` 等），使用 `SoftPhongShader` + `MeshRasterizer` 生成 `MeshRenderer`。
  - 光照使用 `AmbientLights`（没有复杂光照）。

- 网格与可学习参数：
  - 加载 OBJ：`src_mesh = load_objs_as_meshes([obj_filename], device=device)`。
  - 将网格当前的 UV 纹理 `maps_padded()` 复制并设置为可学习参数：`learnable_maps = src_mesh.textures.maps_padded().detach().clone().requires_grad_(True)`。因此优化目标是纹理图（texture map），不是顶点位置或顶点颜色（顶点形变代码被注释掉）。

- 优化设置：
  - 仅使用 RGB L2 损失（losses 字典只保留 `"rgb"`，权重为 2.0）。
  - Optimizer：`torch.optim.Adam([learnable_maps], lr=0.5)`。
  - 迭代次数 `Niter = 500`（可配置）、每次随机选 `num_views_per_iteration = 2` 个视角用于计算损失。
  - 在每次迭代中：将 `learnable_maps` 用于 `TexturesUV` 赋值给 `new_src_mesh.textures`，然后对所选视角渲染并计算 `(predicted_rgb * mask - target_rgb)**2` 的均值作为 RGB 损失。

- 日志与可视化：
  - 使用 TensorBoard (`SummaryWriter`) 写入：GT、渲染图、loss 标量等。
  - 每 `plot_period`（100）步会把当前渲染图写入 TensorBoard。
  - 有 `visualize_prediction` 函数可将 GT 与预测图并列保存为 PNG（在代码中注释掉，替代为 tb_writer 写图）。

- 训练结束与保存：
  - 训练完成后，取 `new_src_mesh` 的顶点、面、法线、UV、faces_uvs、texture maps，调用 `save_obj(...)` 将结果保存为 OBJ，包括 `texture_map`（PNG 或嵌入纹理图由 PyTorch3D 保存函数处理）。

**关键变量与行为要点**
- `DEBUG_IDX = 3`：在读取图像/相机时会中断循环（只读取前 3 张），方便调试但生产运行需调整/移除。
- `learnable_maps`：真正被优化的张量，初始为 OBJ 中已有的纹理图（maps_padded），尺寸为 `[1, H, W, 3]`（padded）。
- 使用 `TexturesUV` 结合 `faces_uvs` 与 `verts_uvs`：保留原 OBJ 的 UV 展开，仅学习纹理图像像素（UV 图像空间）。
- `raster_settings_soft` 使用了 `faces_per_pixel=50`，`bin_size=0`（更精细但可能慢）。`blur_radius` 通过 sigma 计算以获得 soft rasterization。
- 损失：当前仅 optimize RGB；其它正则项（edge, normal, laplacian, silhouette）被注释掉或未使用（但存在函数 `update_mesh_shape_prior_losses` 支持它们）。

**潜在问题 / 注意点**
- `readColmapImages` 将 mask 变量无条件转换为 tensor —— 若 mask 不存在会变成 `None`，但代码随后把 `img_mask = torch.tensor(img_mask, ...)`（当 None 时会报错）。但是在代码中 mask path check 若不存在则 `img_mask = None` 并仍转换成 tensor —— 实际运行应导致异常（需要改为条件转换）。（检查：当前脚本在读取时可能抛异常，除非所有图像都有 mask 文件）
- `image_size` 在 `PerspectiveCameras` 中传入 `[ [img_h, img_w] ]`，PyTorch3D 的 `image_size` 通常是 list of (H, W) — 这里顺序是否正确需根据版本验证（脚本中 img_h=height, img_w=width，用法通常是 `[ (H,W) ]`，看起来是 OK，但注意与 focal/principal point 对应）。
- `faces_per_pixel=50` 和 `bin_size=0` 会导致渲染很慢/消耗大显存，特别是高分辨率或多视图时。
- 保存 OBJ 时传入的参数 `faces_normals_idx=final_faces` 可能不是所需格式（API 版本差异）；若报错需要按当前 PyTorch3D 版本调整 `save_obj` 参数顺序或命名。
- 代码在多个地方注释了形变/顶点颜色学习；目前仅专注纹理优化。

**如何运行（快速指导）**
- 前提：安装好 `torch`, `pytorch3d`, `opencv-python`, `imageio`, `tqdm`, `tensorboard` 等依赖，并保证 CUDA 可用（如想用 GPU）。
- 在包含该脚本的目录直接执行：
  - python 命令：
    ```bash
    python pytorch3d/try_fit_textures.py
    ```
- 查看 TensorBoard（默认 logdir 在脚本中 `log_dir` 变量）：
  ```bash
  tensorboard --logdir /home/stlx/0_server_code/zch/pytorch3d/logs/try_naive_rast_1
  ```
- 调整运行前需确保路径变量（`obj_filename`, `path`, `camera_sub`, `images`）指向有效的数据集与 OBJ。

**改进方向**

- 修复 mask 处理逻辑：仅当 mask 存在时转换为 tensor，否则使用全 1 mask 或跳过 mask 应用。
- 移除或使 `DEBUG_IDX` 可配置以读取全部视图用于训练。
- 增加额外正则项（laplacian、normal、edge）有助于纹理/形状稳定；或者先训练低学习率后恢复高频细节。
- 考虑把 `learnable_maps` 作为 nn.Parameter 并封装到 `nn.Module`，方便保存/加载优化状态、学习率调度等。
- 调低 `faces_per_pixel` 或修改 `bin_size` 以获得更快渲染（权衡质量）。
- 增加命令行参数支持（argparse）使脚本更灵活。
